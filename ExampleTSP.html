<html>

<head>
<title>Solving the IP formulation of a TSP with Cutting Planes - SimplexJS</title>
<script type="text/javascript" src="SimplexJS.js"></script>
<!-- Inspired by http://langexplr.blogspot.com/2008/11/using-canvas-html-element.html -->
<script type="text/javascript">
var numCities = 6;
var cities = [	[ 50, 200],
				[100, 100],
				[100, 300],
				[300, 100],
				[300, 300],
				[350, 200]	];
var curSolution = [];
var dragging = false;
var draggingIndex = -1;
var lastX = -1, lastY = -1;
var subtours = [];

function mouseDownHandler(e)
{
	var x = e.pageX - e.target.offsetLeft;
	var y = e.pageY - e.target.offsetTop;
	for(var i = 0; i < numCities; i++) {
		var dist = (cities[i][0]-x)*(cities[i][0]-x) + (cities[i][1]-y)*(cities[i][1]-y);
		if (dist <= 25*25) {
			dragging = true;
			lastX = x;
			lastY = y;
			draggingIndex = i;
		}
	}
}

function mouseUpHandler(e)
{
	dragging = false;
	lastX = -1;
	lastY = -1;
}

function moveHandler(e) {
	if (dragging) {
		var x = e.pageX - e.target.offsetLeft;
		var y = e.pageY - e.target.offsetTop;
		var deltaX = x - lastX;
		var deltaY = y - lastY;

		cities[draggingIndex][0] += deltaX;
		cities[draggingIndex][1] += deltaY;
 
		lastX = x;
		lastY = y;
		DrawCities();
	}
}

function AddCity() {
	numCities += 1;
	cities.push([Math.random()*400, Math.random()*400]);
	DrawCities();
}


function DrawCities() {
	var canv = document.getElementById("cityContainer");
	var ctxt = canv.getContext("2d");
	ctxt.fillStyle = "#AAAAAA";
	ctxt.fillRect(0, 0, canv.width, canv.height);
	for (i = 0; i < curSolution.length; i++) {
		ctxt.beginPath();
		ctxt.moveTo(cities[curSolution[i][0]][0], cities[curSolution[i][0]][1]);
		ctxt.lineTo(cities[curSolution[i][1]][0], cities[curSolution[i][1]][1]);
		ctxt.closePath();
		ctxt.strokeStyle = "#FF0000";
		ctxt.stroke();
		
	}
	for (i = 0; i < numCities; i++) {
		ctxt.beginPath();
		ctxt.arc(cities[i][0], cities[i][1], 20, 0, Math.PI * 2, false);
		ctxt.closePath();
		ctxt.strokeStyle = "#000000";
		ctxt.stroke();
		ctxt.fillStyle = "#0000FF";
		ctxt.fill();
		ctxt.fillStyle = "#FFFFFF";
		ctxt.font = "bold 12px sans-serif";
		ctxt.fillText(i.toString(), cities[i][0]-5, cities[i][1]+5);
	}
}

function SolveTSP() {
	// Load city locations, and calculate distances
	
	var Cij = new Array(numCities);
	for (i = 0; i < numCities; i++) {
		Cij[i] = new Array(numCities);
		for (j = 0; j < numCities; j++) {
			Cij[i][j] = Math.sqrt( (cities[i][0] - cities[j][0]) * (cities[i][0] - cities[j][0])
								  +(cities[i][1] - cities[j][1]) * (cities[i][1] - cities[j][1]))
		}
	}

	// Create the IP
	var tsp = {};

	// Create cost vector, map arc to column
	// x00 x01 x02 x03 x04 x05 x10 x11 ...
	tsp.n = (numCities)*(numCities-1)/2;
	tsp.c = new Array(tsp.n);
	var col = new Array(), z=0;
	for (i = 0; i < numCities; i++) {
		for (j = i+1; j < numCities; j++) {
			col[[i,j]] = z;
			col[[j,i]] = z;
			tsp.c[z] = Cij[i][j];
			z++;
		}
	}
	
	// Create each row of A and b
	tsp.m = numCities;
	tsp.A = new Array(tsp.m);
	tsp.b = new Array(tsp.m);
	// Degree of each city = 1 (no constraint for last city)
	for (i = 0; i < numCities; i++) {
		tsp.A[i] = new Array(tsp.n);
		for (j = 0; j < tsp.n; j++) tsp.A[i][j] = 0;
		for (j = 0; j < numCities; j++) {
			if (i!=j) tsp.A[i][col[[i,j]]] = 1;
		}
		tsp.b[i] = 2;
	}

	// Set variable bounds and type
	tsp.xLB = new Array(tsp.n);
	tsp.xUB = new Array(tsp.n);
	tsp.xINT = new Array(tsp.n);
	for (i = 0; i < tsp.n; i++) {
		tsp.xLB[i] = 0; tsp.xUB[i] = 1; tsp.xINT[i] = true;
	}
	
	
	// Add subtours
	subtours = []
	eval(document.getElementById("subtoursEntry").value);
	for (st = 0; st < subtours.length; st++) {
		stArcs = subtours[st][0];
		stSize = subtours[st][1];
		// Add the slack for this subtour
		tsp.n += 1;
		tsp.xLB.push(0);
		tsp.xUB.push(Infinity);
		tsp.c.push(0);
		// Modify existing constraints
		for (i = 0; i < tsp.m; i++) tsp.A[i].push(0);
		// Add new constraint
		tsp.m += 1;
		tsp.b.push(stSize);
		tsp.A.push(new Array());
		for (i = 0; i < tsp.n; i++) tsp.A[tsp.m-1][i] = 0;
		for (starc = 0; starc < stArcs.length; starc++) {
			i = stArcs[starc][0];
			j = stArcs[starc][1];
			tsp.A[tsp.m-1][col[[i,j]]] = 1;
		}
	}

	// Solve
	SimplexJS.MAXITERATIONS = 100;
	SimplexJS.SolveMILP(tsp, 20);
	
	// Display answer
	var out = "Solved!<br>Size of branch-and-bound tree was " + tsp.nodeCount.toString() + " (limit: 20)<br>";
	out += tsp.n.toString() + " variables, " + tsp.m.toString() + " constraints.<br>";
	curSolution = [];
	for (i = 0; i < numCities; i++) {
		for (j = i+1; j < numCities; j++) {
			if (tsp.x[col[[i,j]]]) {
				out += "Arc from City " + (i+1).toString() + " to City " + (j+1).toString() + "<br>";
				curSolution.push([i,j]);
			}
		}
	}
	DrawCities();
	document.getElementById("output").innerHTML = out;
}
</script>
</head>

<body onload="DrawCities();">

<table border="1" width = "100%">
<tr>
<td width = "400">
<canvas id="cityContainer" width="400" height="400"
        onmousemove="moveHandler(event);"
        onmousedown="mouseDownHandler(event);"
        onmouseup="mouseUpHandler(event);"
        onmouseout="mouseUpHandler(event);"></canvas>
</td>
<td>
<div id="output"><br><br><br><br><br><br></div><br>
<input type="button" value="Solve TSP using branch-and-bound" onclick="javascript:SolveTSP()"><br>
<input type="button" value="Add city" onclick="javascript:AddCity()"><br>
</td>
</tr>
<tr>
<td colspan="2">
<textarea id="subtoursEntry" cols="100" rows="10">
// Insert subtour elimination constraints here. The model building code will
// evaluate the Javascript in this box. 
// Example:
// subtours.push([ [[0,1], [0,2], [1,2]], 2 ]) // Adds  x01 + x02 + x12 <= 2
</textarea>
</td>
</tr>
</table>



</body>

</html>